<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Как работает симуляция физики в играх на примере Bullet Physics</span><br /><br /></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Многие современные игры используют физическую симуляцию. Первое знакомство с физическим движком обычно многообещающее. Мячик отпрыгивает от куба и катится в низ по наклонной, но в процессе работы, когда проект уже почти готов, оказывается, кое-что работает не так как хотелось. Тут можно угробить уйму времени. <br /><br />И если с Nvidia Physix (привет Unity3D) ничего не поделаешь кроме пары параметров, то Bullet Physics и Box2D доступны в исходных кодах, и от безысходности начинаешь разбираться с тем как что устроено и работает.<br /><br />Разобраться с тем, как все работает очень полезно. Все игровые физические движки очень похожи. Они все impulse base, что означает то, что в каждый фрейм симуляции все (силы) переводяться в импульсы, импульсы складываются, делятся на массу и прибавляются к скоростям (линейной и вращaтельной) объекта, скорость же определяет насколько объект сдвинется в текущем фрейме симуляции. <br /><br />И тут встает вопрос, если все так просто, как получается, что можно выложить в столбик кубики и они себе спокойно стоят и не разлетаются?<br /><br />Я покажу, что за всю эту магию отвечает маленький кусочек кода!<br /><a name="habracut"></a><br />Я предполагаю, что читатель уже знает, что в физическом движке, есть два основных вида симулируемых тел: rigid body (упругое тело, двигается и обладает масой) и static body (неподвижное тело, неподвижно и массой не обладает). Kinematic и soft body не стоят внимания.<br /><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">Collision Detection</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Вся магия начинается когда два тела касаются друг друга. В Bullet Physics используется термин collision. <br /><br />Система должна определить все тела, которые касаются друг друга в данный фрейм симуляции. В каждом касании (коллизии) может участвовать 2 и больше тел. Поиск всех возможных касаний может быть очень ресурсоёмким. <br /><br /></p>
<p style=" margin-top:12px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:small; font-weight:600;">Broadphase Collision Detection</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Первый этап — это найти пересечение AABB коробок. AABB — это две точки, которые описывают коробку внутри которой лежит объект. Идея такая, что если два объекта пересекаются, то и их AABB коробки пересекаются. <br /><br />Эту проблему в BulletPhysics решает один из трёх алгоритмов. Они реализованы в виде классов, реализующих <a href="http://www.continuousphysics.com/Bullet/BulletFull/classbtBroadphaseInterface.html"><span style=" text-decoration: underline; color:#0000ff;">btBroadphaseInterface</span></a>.<br /><br />1. Самый очевидный и неэффективный это btSimpleBroadphase, это простой перебор всех пар O(n^2).<br /><br />2. <a href="http://www.continuousphysics.com/Bullet/BulletFull/classbtAxisSweep3.html"><span style=" text-decoration: underline; color:#0000ff;">btAxisSweep3</span></a> работает в ограниченном пространстве. Вы задаёте AABB коробку, внутри которой предполагается будут находиться все объекты. Это может показаться неудобным, но из- за того, что числа с плавающей точкой с увеличением значения теряют точность, вы все равно не сможете симулировать что-либо на расстоянии миллиона единиц так, как если бы вы это делали на расстоянии 10 единиц от центра координат (единица обычно считается метром).<br /><br />3. <a href="http://www.continuousphysics.com/Bullet/BulletFull/structbtDbvtBroadphase.html"><span style=" text-decoration: underline; color:#0000ff;">btDbvtBroadphase</span></a> организует все объекты в двух древовидных структурах, одно для статических объектов, другое для динамических (rigid, kinematic) тел.<br /><br /></p>
<p style=" margin-top:12px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:small; font-weight:600;">Narrowphase Collision Detection</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />После того, как найдены группы объектов, чьи AABB коробки пересеклись, происходит проверка, есть ли пересечение в действительности. <br /><br />Тут следует вспомнить, что у всех объектов задаётся форма (shape), может быть шар, цилиндр, коробка, выпуклый многогранник для rigid body или просто многогранник для static body. Так же есть составная форма из форм, перечисленных предыдущем предложении. <br /><br />Для каждой пары определён алгоритм нахождения точек и перпендикуляров пересечения. </p>
<p align="center" style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image26652.png" /><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">Решение</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Отлично, все пересечения найдены, что делать дальше? Раз движок у нас impulse based, то следует рассчитать такой импульс, которым пихнуть два коснувшихся объекта, чтобы все выглядело реалистично.<br /><br />Тут я обещала, что будет маленький кусочек кода. Мне кажется года два назад он был вообще тремя строками, но теперь он выглядит так.<br /><br /></p>
<p style=" margin-top:12px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">// Project Gauss Seidel or the equivalent Sequential Impulse </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;"> void btSequentialImpulseConstraintSolver::resolveSingleConstraintRowLowerLimit(btRigidBody&amp; body1,btRigidBody&amp; body2,const btSolverConstraint&amp; c) </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">{ </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    btScalar deltaImpulse = c.m_rhs-btScalar(c.m_appliedImpulse)*c.m_cfm; </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    const btScalar deltaVel1Dotn	=	c.m_contactNormal.dot(body1.internalGetDeltaLinearVelocity()) 	+ c.m_relpos1CrossNormal.dot(body1.internalGetDeltaAngularVelocity()); </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    const btScalar deltaVel2Dotn	=	-c.m_contactNormal.dot(body2.internalGetDeltaLinearVelocity()) + c.m_relpos2CrossNormal.dot(body2.internalGetDeltaAngularVelocity()); </span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New'; color:#6a1009;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    deltaImpulse	-=	deltaVel1Dotn*c.m_jacDiagABInv; </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    deltaImpulse	-=	deltaVel2Dotn*c.m_jacDiagABInv; </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    const btScalar sum = btScalar(c.m_appliedImpulse) + deltaImpulse; </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    if (sum &lt; c.m_lowerLimit) </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    { </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">        deltaImpulse = c.m_lowerLimit-c.m_appliedImpulse; </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">        c.m_appliedImpulse = c.m_lowerLimit; </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    } </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    else </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    { </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">        c.m_appliedImpulse = sum; </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    } </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    body1.internalApplyImpulse(c.m_contactNormal*body1.internalGetInvMass(),c.m_angularComponentA,deltaImpulse); </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">    body2.internalApplyImpulse(-c.m_contactNormal*body2.internalGetInvMass(),c.m_angularComponentB,deltaImpulse); </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />На входе имеем два коснувшихся тела, точку касания с перпендикуляром касания и как результат у нас два импульса, которые должны разрешить коллизию, заставить коробки спокойно и неподвижно лежать одну на другой, а цилиндр и шар, плавно и реалистично катиться по наклонной. <br /><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">Полезный совет вместо прощания</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Трогать этот код не стоит. Например, если вы будете разрабатывать игру с гоночным авто, и машина будет биться о бордюр или стену, и она будет вести себя непредсказуемо и не играбельно, то стоит обратить внимание на перпендикуляр в точке касания. Именно непостоянство и непредсказуемость перпендикуляра в точке касания часто определяет непредсказуемость симуляции. <br /><br />Вы заглянули в душу современного физического движка и теперь обязаны на нем жениться.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p></body></html>
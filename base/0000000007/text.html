<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Написание скриптов с графическим интерфейсом.</span><br /><br />Да-да. Именно так. И это не глупость. Есть множество различных инструментов для создания несложных скриптов с минимальным, но всё-таки графическим интерфейсом. В качестве примера можно привести консольный <span style=" font-weight:600; font-style:italic;">dialog</span>, и графические <span style=" font-weight:600; font-style:italic;">gtkdialog</span> и <span style=" font-weight:600; font-style:italic;">kdialog</span>.<br /><br />Консольный dialog строит интерфейс используя библиотеку ncurses. Это удобно для скриптов, которые будут запускаться администратором на серверах. Для скриптов, которые будут запускаться пользователем в графическом режиме лучше использовать gtkdialog или kdialog. gtkdialog использует библиотеку gtk и потому удобен для скриптов, которые будут запускаться в GNOME/XFCE. kdialog является частью пакета kdebase графической среды KDE и соответственно использует её библиотеки.<br /><br />Поскольку автор этих строк является приверженцем KDE, то рассматриваться далее будет исключительно kdialog. Если кто-то из читателей хочет использовать dialog или gtkdialog - ему следует обратиться к документации на эти проекты. Хотя общие принципы использования одинаковы для всех реализаций, и эта заметка, несомненно, будет полезна и им.<br /><br />Кроме того есть интересная библиотека для создания пользовательских оповещений - <span style=" font-weight:600; font-style:italic;">libnotify</span>. Она тоже будет нам полезна. Использовать её можно с помощью утилиты <span style=" font-weight:600; font-style:italic;">notify-send</span> для командной строки.<br /><br /><br /><span style=" font-weight:600; text-decoration: underline;">Задача №1</span>: скрипт для перекодирования файлов<br /><br />Итак. Для начала поставим простую задачу: написать скрипт, перекодирующий произвольный текстовый файл в utf-8. Нам нужно организовать выбор исходного файла, конечного файла и кодировки исходного файла. Дабы не говорить лишних слов, сразу посмотрим на готовый скрипт с комментариями автора:<br /><br />-----8&lt;-----<br />#!/bin/sh<br /><br /># Получаем имя исходного файла<br />SRCFILENAME=`kdialog --getopenfilename . '*.*'`<br /><br /># Если имя файла не пустое идём дальше<br />if (test ${SRCFILENAME}1 != "1") then<br /><br /># Получаем имя конечного файла<br />DSTFILENAME=`kdialog --getsavefilename . '*.*'`<br /><br /># Если имя файла не пустое идём дальше<br />if (test ${DSTFILENAME}1 != "1") then<br /><br /># Если конечный и начальный файл один и тот же -<br /># Завершаем скрипт с сообщением об ошибке<br />if (test ${SRCFILENAME} = ${DSTFILENAME}) then<br />kdialog --sorry 'Нельзя перекодировать файл сам в себя!'<br />exit 1<br />fi<br /><br /># Получаем список доступных кодировок<br />ENCODINGLIST=`iconv -l | sed 's/\/\///'| awk '{ print $1 " " $1}'|sort`<br /><br /># Запрашиваем кодировку исходного файла<br />ENCODING=`kdialog --menu 'Выберите кодировку:' ${ENCODINGLIST}`<br /><br /># Если кодировка выбрана - перекодируем файл и сообщаем об<br /># успешном завершении скрипта<br />if (test ${ENCODING}1 != "1") then<br /><br />iconv -f ${ENCODING} -t utf-8 ${SRCFILENAME} &gt; ${DSTFILENAME}<br />kdialog --msgbox 'Перекодирование выполнено!'<br /><br />fi<br /><br />fi<br /><br />fi<br /><br />-----8&lt;-----<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В скрипте мы сначала показываем диалог выбора имени файла, если файл выбран - запрашиваем второе имя. Если первое и второе имя совпадают - завершаем скрипт. Если же нет - запрашиваем кодировку исходного файла. Если кодировка выбрана - выполняем перекодировку. Больше к этому добавить нечего. Перейдём ко второй задаче:<br /><br /><br /><span style=" font-weight:600; text-decoration: underline;">Задача №2</span>: Проверка доступности сетевого ресурса.<br /><br />Вторая задача чуть проще - нам нужно периодически проверять доступность сетевого ресурса и как только он становится недоступным - оповестить пользователя. Так же пользователя нужно оповестить и в момент доступности ресурса. Опять же сразу готовое решение с комментариями автора:<br /><br />-----8&lt;-----<br />#!/bin/sh<br /><br /># Ресурс, доступность которого нужно проверять.<br />PINGRESOURCE="ylsoftware.com"<br /><br /># Файл, который будет создаваться если ресурс недоступен<br />LOCKFILE="/tmp/${PINGRESOURCE}.lock"<br /><br /># Интервал (в секундах) между проверками<br />CHECKTIME=60<br /><br /># Организуем бесконечный цикл<br />while true; do<br /><br /># Если ресурс не доступен<br />if (! ping -c 3 ${PINGRESOURCE} &gt; /dev/null 2&gt; /dev/null) then<br /><br /># Проверяем наличие временного файла<br />if (! test -f ${LOCKFILE}) then<br /># Если временный файл не существует - создаём его<br /># и оповещаем пользователя<br />touch ${LOCKFILE}<br />kdialog --sorry 'Ресурс недоступен!'<br />fi<br /><br /># Если же доступен<br />else<br /># Проверяем наличие временного файл<br />if (test -f ${LOCKFILE}) then<br /><br /># Если файл существует - удаляем его и оповещаем<br /># Пользователя о доступности<br />rm ${LOCKFILE}<br />kdialog --msgbox 'Ресурс доступен!'<br />fi<br />fi<br /><br />sleep ${CHECKTIME}<br />done<br /><br />-----8&lt;-----<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Комментарии тут вобщем-то излишни. Однако диалоговые окна иногда отвлекают. Проблему можно решить заменив их на всплывающие оповещения. Для этого вызовы kdialog надо заменить на вызовы notify-send. В этом случае скрипт примет вид:<br /><br />-----8&lt;-----<br /><br />#!/bin/sh<br /><br /># Ресурс, доступность которого нужно проверять.<br />PINGRESOURCE="ylsoftware.com"<br /><br /># Файл, который будет создаваться если ресурс недоступен<br />LOCKFILE="/tmp/${PINGRESOURCE}.lock"<br /><br /># Интервал (в секундах) между проверками<br />CHECKTIME=60<br /><br /># Организуем бесконечный цикл<br />while true; do<br /><br /># Если ресурс не доступен<br />if (! ping -c 3 ${PINGRESOURCE} &gt; /dev/null 2&gt; /dev/null) then<br /><br /># Проверяем наличие временного файла<br />if (! test -f ${LOCKFILE}) then<br /># Если временный файл не существует - создаём его<br /># и оповещаем пользователя<br />touch ${LOCKFILE}<br />notify-send ${PINGRESOURCE} 'Ресурс недоступен!'<br />fi<br /><br /># Если же доступен<br />else<br /># Проверяем наличие временного файл<br />if (test -f ${LOCKFILE}) then<br /><br /># Если файл существует - удаляем его и оповещаем<br /># Пользователя о доступности<br />rm ${LOCKFILE}<br />notify-send ${PINGRESOURCE} 'Ресурс доступен!'<br />fi<br />fi<br /><br />sleep ${CHECKTIME}<br />done<br /><br />-----8&lt;-----<br /><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Заключение</span><br /><br />В принципе на этом можно закончить. Подробное рассмотрение этой темы займёт целую книгу, в то время как здесь представлены лишь поверхностные сведения, которые показывают только основные идеи, используемые при написании скриптов с графическим интерфейсом. Автор надеется что эта заметка получилась полезной и интересной.<br /><br />MooSE 2008-02-28 11:34:34<br />http://ylsoftware.com/?action=news&amp;na=viewfull&amp;news=405<br /></p></body></html>
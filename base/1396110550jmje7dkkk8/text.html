<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Отношение C++ к инициализации значений объектов может показаться странным. Например, если вы пишете:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int x;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">то в некоторых контекстах переменная x будет гарантированно инициализирована нулем, а в других – нет. Если вы пишете:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">class Point {</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int x, y;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">};</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">Point p;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">то члены-данные объекта p иногда будут инициализированы (нулями), а иногда – нет. Если вы перешли к C++ от языка, где неинициализированные объекты не могут существовать, обратите на это внимание.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Чтение неинициализированных значений может быть причиной неопределенного поведения. На некоторых платформах такое простое действие, как доступ к неинициированному значению для чтения, может вызвать аварийную остановку программы. Но чаще вы получите случайный набор битов, который испортит внутреннее состояние объекта, в который они записываются, и в конечном итоге это приведет к необъяснимому поведению программы и длительному поиску ошибки в отладчике.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Сформулируем правила, которые описывают, когда инициализация объекта гарантируется, а когда нет. К сожалению, эти правила достаточно сложны – на мой взгляд, слишком сложны, чтобы их стоило запоминать. Вообще, если вы работаете с C-частью C++ (см. правило 1) и инициализация может стоить определенных затрат во время исполнения, то не гарантируется, что она произойдет. Это объясняет, почему содержимое массивов (в C-части C++) не обязательно инициализируется, а содержимое вектора (из STL-части C++) инициализируется всегда.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">По-видимому, лучший способ поведения в такой неопределенной ситуации – <span style=" font-style:italic;">всегда</span> инициализировать объекты, прежде чем их использовать. Для объектов встроенных типов, не являющихся членами классов, это нужно делать вручную. Например:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int x = 0; // ручная инициализация int</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">const char * text = “Строка в стиле C”; // ручная инициализация указателя</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">// (см. также правило 3)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">double d; // «инициализация» чтением</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">std::cin &gt;&gt; d; // из входного потока</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Почти во всех остальных случаях ответственность за инициализацию ложится на конструкторы. Правило простое: убедитесь, что все конструкторы инициализируют в объекте всё.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этому правилу легко следовать, но важно не путать присваивание с инициализацией. Рассмотрим конструктор класса, представляющего записи в адресной книге:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">class PhoneNumber {…}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">class ABEntry { // ABEntry = “Address Book Entry”</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">public:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">ABEntry(const std::string&amp; name, const std::string&amp; address,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">const std::list&lt;PhoneNumber&gt;&amp; phones);</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">private:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">std::string theName;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">std::string theAddress;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">std::list&lt;PhoneNumber&gt; thePhones;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int numTimesConsulted;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">};</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">ABEntry(const std::string&amp; name, const std::string&amp; address,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">const std::list&lt;PhoneNumber&gt;&amp; phones)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">theName = name; // все это </span><span style=" font-family:'Courier 10 Pitch'; font-style:italic; color:#6a0e07;">присваивание</span><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">, а не инициализация</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">theAddress = address;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">thePhones = phones;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">numTimesConsulted = 0;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Да, в результате порождаются объекты ABEntry со значениями, которых вы ожидаете, но это все же не лучший подход. Правила C++ оговаривают, что члены объекта инициируются <span style=" font-style:italic;">перед</span> входом в тело конструктора. То есть внутри конструктора ABEntry члены theName, theAddress и thePhones не инициализируются, а им <span style=" font-style:italic;">присваиваются</span> значения. Инициализация происходит ранее: когда автоматически вызываются их конструкторы перед входом в тело конструктора ABEntry. Это не касается numTimesConsulted, поскольку этот член относится к встроенному типу. Для него нет никаких гарантий того, что он вообще будет инициализирован перед присваиванием.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Лучший способ написания конструктора ABEntry – использовать список инициализации членов вместо присваивания:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">ABEntry(const std::string&amp; name, const std::string&amp; address,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">const std::list&lt;PhoneNumber&gt;&amp; phones)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">:theName(name), // теперь это все – </span><span style=" font-family:'Courier 10 Pitch'; font-style:italic; color:#6a0e07;">инициализации</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">:theAddress(address),</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">thePhones(phones),</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">:numTimesConsulted(0)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{} // тело конструктора теперь пусто</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот конструктор дает тот же самый конечный результат, что и предыдущий, но часто оказывается более эффективным. Версия, основанная на присваиваниях, сначала вызывает конструкторы по умолчанию для инициализации theName, theAddress и thePhones, а затем сразу присваивает им новые значения, затирая те, что уже были присвоены в конструкторах по умолчанию. Таким образом, вся работа конструкторов по умолчанию тратится впустую. Подход со списком инициализации членов позволяет избежать этой проблемы, поскольку аргументы в списке инициализации используются в качестве аргументов конструкторов для различных членов-данных. В этом случае theName создается конструктором копирования из name, theAddress – из address, thePhones – из phones. Для большинства типов единственный вызов конструктора копирования более эффективен – иногда <span style=" font-style:italic;">намного</span> более эффективен, чем вызов конструкторов по умолчанию с последующим вызовом операторов присваивания.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Для объектов встроенных типов вроде numTimesConsulted нет разницы по затратам между инициализацией и присваиванием, но для единообразия часто лучше инициировать все посредством списка инициализации членов. Такие списки можно применять даже тогда, когда данные-члены инициализируются конструкторами по умолчанию: просто не передавайте никаких аргументов соответствующему конструктору. Например, если у ABEntry есть конструктор, не принимающий параметров, то он может быть реализован примерно так:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">ABEntry()</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">:theName(), // вызвать конструктор по умолчанию для theName</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">:theAddress(), // сделать то же для theAddress и для thePhones;</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">thePhones(), // но явно инициализировать нулем numTimesConsulted</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">:numTimesConsulted(0)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Поскольку компилятор автоматически вызывает конструкторы по умолчанию для данных-членов пользовательских типов, когда для них отсутствуют инициализаторы в списке инициализации членов, некоторые программисты считают приведенный выше код избыточным. Это понятно, но, придерживаясь политики всегда перечислять все данные-члены в списках инициализации, вы избавляете себя от необходимости помнить, какие члены будут инициализированы, если их пропустить, а какие – нет. Например, поскольку numTimesConsulted относится к встроенному типу, то исключение его из списка инициализации может открыть двери неопределенному поведению.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Иногда список инициализации просто <span style=" font-style:italic;">необходимо</span> использовать, даже для встроенных типов. Например, данные-члены, которые являются константами либо ссылками, обязаны быть инициализированы, так как они не могут получить значения посредством присваивания (см. также правило 5). Чтобы избежать необходимости помнить, когда данные-члены должны быть инициализированы в списке инициализации, а когда это не обязательно, проще делать это <span style=" font-style:italic;">всегда.</span> Иногда это обязательно, а часто – более эффективно, чем присваивание.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Во многих классах есть несколько конструкторов, и каждый конструктор имеет свой собственный список инициализации. Если у класса много данных-членов или базовых классов, то наличие большого числа списков инициализации порождает нежелательное дублирование кода (в списках) и тоску (у программистов). В таких случаях имеет смысл опустить в списках инициализации те данные-члены, для которых присваивание работает так же, как настоящая инициализация, переместив инициализацию в одну (обычно закрытую) функцию, которую вызывают все конструкторы. Этот подход может быть особенно полезен, если начальные значения должны быть загружены из файла или базы данных. Однако, вообще говоря, инициализация членов посредством списков инициализации более предпочтительна, чем псевдоинициализация присваиванием.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Один из аспектов C++, на который можно положиться, – это порядок, в котором инициализируются данные объектов. Этот порядок всегда один и тот же: базовые классы инициализируются раньше производных (см. также правило 12), а внутри класса члены-данные инициализируются в том порядке, в котором объявлены. Например, в классе ABEntry член theName всегда будет инициализирован первым, theAddress – вторым, thePhones – третьим, а numTimesConsulted – последним. Это верно даже в случае, если в списке инициализации членов они перечислены в другом порядке (что, к сожалению, не запрещено). Чтобы не вводить в заблуждение человека, читающего вашу программу, и во избежание ошибок непонятного происхождения, всегда перечисляйте данные-члены в списке инициализации в том порядке, в котором они объявлены в классе.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Позаботившись о явной инициализации объектов встроенных типов, которые не являются членами классов, и обеспечив правильную инициализацию базовых классов и их данных-членов посредством списков инициализации, у вас останется только одна вещь, о чем нужно будет подумать. Речь идет о порядке инициализации нелокальных статических объектов, объявленных в разных единицах трансляции.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Отнесемся к этой фразе со всем вниманием.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">Статический объект</span> существует от момента, когда был сконструирован, и до конца работы программы. Объекты, размещенные в стеке и в «куче», к статическим не относятся. Статическими являются глобальные объекты, объекты, объявленные в области действия пространства имен, объекты, объявленные с ключевым словом static внутри классов и функций, а также в области действия отдельного файла с исходным текстом. Статические объекты, объявленные внутри функций, известны как <span style=" font-style:italic;">локальные статические объекты</span> (поскольку они локальны по отношению к функции), а все прочие называют <span style=" font-style:italic;">нелокальными статическими объектами.</span> Статические объекты автоматически уничтожаются при завершении программы, то есть при выходе из функции main() автоматически вызываются их деструкторы.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">Единица трансляции (translation unit)</span> – это исходный код, который порождает отдельный объектный файл. Обычно это один исходный файл плюс все файлы, включенные в него директивой #include.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Проблема возникает, когда есть, по крайней мере, два отдельно компилируемых исходных файла, каждый из которых содержит, по крайней мере, один нелокальный статический объект (то есть глобальный объект либо объявленный в области действия пространства имен, класса или файла). Суть ее в том, что если инициализация нелокального статического объекта происходит в одной единице трансляции, а используется он в другой, то такой объект может оказаться неинициализированным в момент использования, поскольку <span style=" font-style:italic;">относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рассмотрим пример. Предположим, у вас есть класс FileSystem, который делает файлы из Internet неотличимыми от локальных. Поскольку ваш класс представляет мир как единую файловую систему, вы могли бы создать в глобальной области действия или в пространстве имен соответствующий ей специальный объект:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">class FileSystem { // из вашей библиотеки</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">public:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">std::size_t numDisks() const; // одна из многих функций-членов</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">};</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">extern FileSystem tfs; // объект для использования клиентами</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">// “tfs” = “the file system”</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Класс FileSystem определенно не тривиален, поэтому использование объекта theFileSystem до того, как он будет сконструирован, приведет к катастрофическим последствиям.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Теперь предположим, что некий пользователь создает класс, описывающий каталоги файловой системы. Естественно, его класс будет использовать объект theFileSystem:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">class Directory { // создан пользователем</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">public:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">Directory( params );</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">};</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">Directory::Directory( params )</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">std::size_t disks = tfs.numDisks(); // использование объекта tfs</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Далее предположим, что пользователь решает создать отдельный глобальный объект класса Directory, представляющий каталог для временных файлов:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">Directory tempDir( params ); // каталог для временных файлов</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Теперь проблема порядка инициализации становится очевидной: если объект tfs не инициализирован раньше, чем tempDir, то конструктор tempDir попытается использовать tfs до его инициализации. Но tfs и tempDir были созданы разными людьми в разное время и находятся в разных исходных файлах – это нелокальные статические объекты, определенные в разных единицах трансляции. Как вы можете быть уверены, что tfs будет инициализирован раньше, чем tempDir?</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Да никак! Еще раз повторю: <span style=" font-style:italic;">относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</span> На то есть своя причина. Определить «правильный» порядок инициализации нелокальных статических объектов трудно. Очень трудно. Неразрешимо трудно. В наиболее общем случае – при наличии многих единиц трансляции и нелокальных статических объектов, сгенерированных путем неявной конкретизации шаблонов (которые и сами могут быть результатом неявной конкретизации других шаблонов) – не только невозможно определить правильный порядок инициализации, но обычно даже не стоит искать частные случаи, когда этот порядок в принципе определить можно.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">К счастью, небольшое изменение в проекте программы позволяет полностью устранить эту проблему. Нужно лишь переместить каждый нелокальный статический объект в отдельную функцию, в которой он будет объявлен статическим. Эти функции возвращают ссылки на объекты, которые в них содержатся. Клиенты затем вызывают функции вместо непосредственного обращения к объектам. Другими словами, нелокальные статические объекты заменяются <span style=" font-style:italic;">локальными</span> статическими объектами (знакомые с паттернами проектирования легко узнают в этом описании типичную реализацию паттерна Singleton).</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот подход основан на том, что C++ гарантирует: локальные статические объекты инициализируются в первый раз, когда определение объекта встречается при вызове этой функции. Поэтому если вы замените прямой доступ к нелокальным статическим объектам вызовом функций, возвращающих ссылки на расположенные внутри них локальные статические объекты, то можете быть уверены, что ссылки, возвращаемые из функций, будут ссылаться на инициализированные объекты. Дополнительное преимущество заключается в том, что если вы никогда не вызываете функцию, эмулирующую нелокальный статический объект, то и не придется платить за создание и уничтожение объекта, чего не скажешь о реальных нелокальных статических объектах.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Вот как этот прием применяется к объектам tfs и tempDir:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">class FileSystem {...}; // как раньше</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">FileSystem&amp; tfs() // эта функция заменяет объект tfs, она может</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{ // быть статической в классе FileSystem</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">static FileSystem fs; // определение и инициализация локального</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">// статического объекта</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">return fs; // возврат ссылки на него</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">class Directory {...}; // как раньше</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">Directory::Directory( </span><span style=" font-family:'Courier 10 Pitch'; font-style:italic; color:#6a0e07;">params </span><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">) // как раньше, но вместо ссылки на tfs</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{ // вызов tfs()</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">std::size_t disks = tfs().numDisks();</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">...</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">Directory&amp; tempDir() // эта функция заменяет объект tempDir,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{ // может быть статической в классе Directory</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">static Directory td; // определение/инициализация локального</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">// статического объекта</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">return td; // возврат ссылки на него</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Клиенты работают с этой модифицированной программой так же, как раньше, за исключением того, что вместо tfs и tempDir они теперь обращаются к tfs() и tempDir(). Иными словами, используют ссылки на объекты, возвращенные функциями, вместо использования самих объектов.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функции, которые в соответствии с данной схемой возвращают ссылки, всегда просты: определить и инициализировать локальный статический объект в строке 1 и вернуть его в строке 2. В связи с этим у вас может возникнуть искушение объявить их встроенными, особенно, если они часто вызываются (см. правило 30). С другой стороны, тот факт, что эти функции содержат в себе статические объекты, усложняет их применение в многопоточных системах. Но тут никуда не деться: неконстантные статические объекты любого рода – локальные или нелокальные – представляют проблему в случае наличия в программе нескольких потоков. Решить ее можно, например, вызвав самостоятельно все функции, возвращающие ссылки, на этапе запуска программы, когда еще работает только один поток. Это исключит неопределенность в ходе инициализации.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Конечно, применимость идеи функций, возвращающих ссылки, для предотвращения проблем, связанных с порядком инициализации, зависит от того, существует ли в принципе разумный порядок инициализации ваших объектов. Если вы напишете код, в котором объект A должен быть инициализирован прежде, чем объект B, и одновременно сделаете инициализацию A зависимой от инициализации B, то вас ждут проблемы – и поделом! Если, однако, вы будете избегать таких патологических ситуаций, то описанная схема сослужит вам добрую службу, по крайней мере, в однопоточных приложениях.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таким образом, чтобы избежать использования объектов до их инициализации, вам следует сделать три вещи. Первое: вручную инициализировать не являющиеся членами объекты встроенных типов. Второе: использовать списки инициализации членов для всех частей объекта. И наконец, третье: обойти за счет правильного проектирования проблему негарантированного порядка инициализации нелокальных статических объектов, определенных в разных единицах трансляции.</p>
<p style="-qt-paragraph-type:empty; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; font-style:italic;">Что следует помнить</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• Всегда вручную инициализировать объекты встроенных типов, поскольку C++ делает это, только не всегда.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• В конструкторе отдавать предпочтение применению списков инициализации членов перед прямым присваиванием значений в теле конструктора. Перечисляйте данные-члены в списке инициализации в том же порядке, в каком они объявлены в классе.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• Избегайте проблем с порядком инициализации в разных единицах трансляции, заменяя нелокальные статические объекты локальными статическими объектами.</p>
<p style="-qt-paragraph-type:empty; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>
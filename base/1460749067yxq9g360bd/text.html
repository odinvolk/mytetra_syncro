<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">Я постараюсь окончательно разобрать такие тонкие понятия в C и C++, как указатели, ссылки и массивы. В частности, я отвечу на вопрос: являются ли массивы C указателями или нет.</span><br /></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Обозначения и предположения</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Я буду предполагать, что читатель понимает, что, например, в C++ есть ссылки, а в C — нет, поэтому я не буду постоянно напоминать, о каком именно языке (C/C++ или именно C++) я сейчас говорю, читатель поймёт это из контекста;</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Также, я предполагаю, что читатель уже знает C и C++ на базовом уровне и знает, к примеру, синтаксис объявления ссылки. В этом посте я буду заниматься именно дотошным разбором мелочей;</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Буду обозначать типы так, как выглядело бы объявление переменной TYPE соответствующего типа. Например, тип «массив длины 2 int'ов» я буду обозначать как <span style=" font-family:'Courier New,courier';">int TYPE[2]</span>;</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Я буду предполагать, что мы в основном имеем дело с обычными типами данных, такими как <span style=" font-family:'Courier New,courier';">int TYPE</span>, <span style=" font-family:'Courier New,courier';">int *TYPE</span> и т. д., для которых операции =, &amp;, * и другие не переопределены и обозначают обычные вещи;</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">«Объект» всегда будет означать «всё, что не ссылка», а не «экземпляр класса»;</li>
<li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Везде, за исключением специально оговоренных случаев, подразумеваются C89 и C++98.</li></ul>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Указатели и ссылки</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Указатели</span>. Что такое указатели, я рассказывать не буду. :) Будем считать, что вы это знаете. Напомню лишь следующие вещи (все примеры кода предполагаются находящимися внутри какой-нибудь функции, например, main):</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int x;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int *y = &amp;x; // От любой переменной можно взять адрес при помощи операции взятия адреса &quot;&amp;&quot;. Эта операция возвращает указатель</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int z = *y; // Указатель можно разыменовать при помощи операции разыменовывания &quot;*&quot;. Это операция возвращает тот объект, на который указывает указатель</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Также напомню следующее: char — это всегда ровно один байт и во всех стандартах C и C++ <span style=" font-family:'Courier New,courier';">sizeof (char) == 1</span> (но при этом стандарты не гарантируют, что в байте содержится именно 8 бит :)). Далее, если прибавить к указателю на какой-нибудь тип T число, то реальное численное значение этого указателя увеличится на это число, умноженное на <span style=" font-family:'Courier New,courier';">sizeof (T)</span>. Т. е. если p имеет тип <span style=" font-family:'Courier New,courier';">T *TYPE</span>, то <span style=" font-family:'Courier New,courier';">p + 3</span> эквивалентно <span style=" font-family:'Courier New,courier';">(T *)((char *)p + 3 * sizeof (T))</span>. Аналогичные соображения относятся и к вычитанию.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Ссылки</span>. Теперь по поводу ссылок. Ссылки — это то же самое, что и указатели, но с другим синтаксисом и некоторыми другими важными отличиями, о которых речь пойдёт дальше. Следующий код ничем не отличается от предыдущего, за исключением того, что в нём фигурируют ссылки вместо указателей:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int x;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int &amp;y = x;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int z = y;</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если слева от знака присваивания стоит ссылка, то нет никакого способа понять, хотим мы присвоить самой ссылке или объекту, на который она ссылается. Поэтому такое присваивание всегда присваивает объекту, а не ссылке. Но это не относится к инициализации ссылки: инициализируется, разумеется, сама ссылка. Поэтому после инициализации ссылки нет никакого способа изменить её саму, т. е. ссылка всегда постоянна (но не её объект).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Lvalue</span>. Те выражения, которым можно присваивать, называются lvalue в C, C++ и многих других языках (это сокращение от «left value», т. е. слева от знака равенства). Остальные выражения называются rvalue. Имена переменных очевидным образом являются lvalue, но не только они. Выражения:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">a[i + 2]</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">и</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">some_struct.some_field, *ptr, *(ptr + 3) </span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">— тоже lvalue.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Удивительный факт состоит в том, что ссылки и lvalue — это в каком-то смысле одно и то же. Давайте порассуждаем. Что такое lvalue? Это нечто, чему можно присвоить. Т. е. это некое фиксированное место в памяти, куда можно что-то положить. Т. е. адрес. Т. е. указатель или ссылка (как мы уже знаем, указатели и ссылки — это два синтаксически разных способа в C++ выразить понятие адреса). Причём скорее ссылка, чем указатель, т. к. ссылку можно поместить слева от знака равенства и это будет означать присваивание объекту, на который указывает ссылка. Значит, lvalue — это ссылка.<br /><br />А что такое ссылка? Это один из синтаксисов для адреса, т. е., опять-таки, чего-то, куда можно класть. И ссылку можно ставить слева от знака равенства. Значит, ссылка — это lvalue.<br /><br />Окей, но ведь (почти любая) переменная тоже может быть слева от знака равенства. Значит, (такая) переменная — ссылка? Почти. Выражение, представляющее собой переменную — ссылка.</span><br /><br />Иными словами, допустим, мы объявили <span style=" font-family:'Courier New,courier';">int x</span>. Теперь x — это переменная типа <span style=" font-family:'Courier New,courier';">int TYPE</span> и никакого другого. Это int и всё тут. Но если я теперь пишу <span style=" font-family:'Courier New,courier';">x + 2</span> или <span style=" font-family:'Courier New,courier';">x = 3</span>, то в этих выражениях подвыражение <span style=" font-family:'Courier New,courier';">x</span> имеет тип <span style=" font-family:'Courier New,courier';">int &amp;TYPE</span>. Потому что иначе этот x ничем не отличался бы от, скажем, 10, и ему (как и десятке) нельзя было бы ничего присвоить.<br /><br />Этот принцип («выражение, являющееся переменной — ссылка») — моя выдумка. Т. е. ни в каком учебнике, стандарте и т. д. я этот принцип не видел. Тем не менее, он многое упрощает и его удобно считать верным. Если бы я реализовывал компилятор, я бы просто считал там переменные в выражениях ссылками, и, вполне возможно, именно так и предполагается в реальных компиляторах.<br /><br />Более того, удобно считать, что особый тип данных для lvalue (т. е. ссылка) существует даже и в C. Именно так мы и будет дальше предполагать. Просто понятие ссылки нельзя выразить синтаксически в C, ссылку нельзя объявить.<br /><br />Принцип «любое lvalue — ссылка» — тоже моя выдумка. А вот принцип «любая ссылка — lvalue» — вполне законный, общепризнанный принцип (разумеется, ссылка должна быть ссылкой на изменяемый объект, и этот объект должен допускать присваивание).<br /><br />Теперь, с учётом наших соглашений, сформулируем строго правила работы со ссылками: если объявлено, скажем, <span style=" font-family:'Courier New,courier';">int x</span>, то теперь выражение x имеет тип <span style=" font-family:'Courier New,courier';">int &amp;TYPE</span>. Если теперь это выражение (или любое другое выражение типа ссылка) стоит слева от знака равенства, то оно используется именно как ссылка, практически во всех остальных случаях (например, в ситуации <span style=" font-family:'Courier New,courier';">x + 2</span>) x автоматически конвертируется в тип <span style=" font-family:'Courier New,courier';">int TYPE</span> (ещё одной операцией, рядом с которой ссылка не конвертируется в свой объект, является &amp;, как мы увидим далее). Слева от знака равенства может стоять только ссылка. Инициализировать (неконстантную) ссылку может только ссылка.<br /><br /><span style=" font-weight:600;">Операции * и &amp;</span>. Наши соглашения позволяют по-новому взглянуть на операции * и &amp;. Теперь становится понятно следующее: операция * может применяться только к указателю (конкретно это было всегда известно) и она возвращает ссылку на тот же тип. &amp; применяется всегда к ссылке и возвращает указатель того же типа. Таким образом, * и &amp; превращают указатели и ссылки друг в друга. Т. е. по сути они вообще ничего не делают и лишь заменяют сущности одного синтаксиса на сущности другого! Таким образом, &amp; вообще-то не совсем правильно называть операцией взятия адреса: она может быть применена лишь к уже существующему адресу, просто она меняет синтаксическое воплощение этого адреса.<br /><br />Замечу, что указатели и ссылки объявляются как <span style=" font-family:'Courier New,courier';">int *x</span> и <span style=" font-family:'Courier New,courier';">int &amp;x</span>. Таким образом, принцип «объявление подсказывает использование» лишний раз подтверждается: объявление указателя напоминает, как превратить его в ссылку, а объявление ссылки — наоборот.<br /><br />Также замечу, что <span style=" font-family:'Courier New,courier';">&amp;*EXPR</span> (здесь EXPR — это произвольное выражение, не обязательно один идентификатор) эквивалентно EXPR всегда, когда имеет смысл (т. е. всегда, когда EXPR — указатель), а <span style=" font-family:'Courier New,courier';">*&amp;EXPR</span> тоже эквивалентно EXPR всегда, когда имеет смысл (т. е. когда EXPR — ссылка).<br /><br /></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Массивы</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Итак, есть такой тип данных — массив. Определяются массивы, например, так:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int x[5];</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Выражение в квадратных скобках должно быть непременно константой времени компиляции в C89 и C++98. При этом в квадратных скобках должно стоять число, пустые квадратные скобки не допускаются.<br /><br />Подобно тому, как все локальные переменные (напомню, мы предполагаем, что все примеры кода находятся внутри функций) находятся на стеке, массивы тоже находятся на стеке. Т. е. приведённый код привёл к выделению прямо на стеке огромного блока памяти размером <span style=" font-family:'Courier New,courier';">5 * sizeof (int)</span>, в котором целиком размещается наш массив. Не нужно думать, что этот код объявил некий указатель, который указывает на память, размещённую где-то там далеко, в куче. Нет, мы объявили массив, самый настоящий. Здесь, на стеке.<br /><br />Чему будет равно <span style=" font-family:'Courier New,courier';">sizeof (x)</span>? Разумеется, оно будет равно размеру нашего массива, т. е. <span style=" font-family:'Courier New,courier';">5 * sizeof (int)</span>. Если мы пишем</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">struct foo</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  int a[5];</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  int b;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">};</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">то, опять-таки, место для массива будет целиком выделяться прямо внутри структуры, и sizeof от этой структуры будет это подтверждать.<br /><br />От массива можно взять адрес (<span style=" font-family:'Courier New,courier';">&amp;x</span>), и это будет самый настоящий указатель на то место, где этот массив расположен. Тип у выражения <span style=" font-family:'Courier New,courier';">&amp;x</span>, как легко понять, будет <span style=" font-family:'Courier New,courier';">int (*TYPE)[5]</span>. В начале массива размещён его нулевой элемент, поэтому адрес самого массива и адрес его нулевого элемента численно совпадают. Т. е. <span style=" font-family:'Courier New,courier';">&amp;x</span> и <span style=" font-family:'Courier New,courier';">&amp;(x[0])</span> численно равны (тут я лихо написал выражение <span style=" font-family:'Courier New,courier';">&amp;(x[0])</span>, на самом деле в нём не всё так просто, к этому мы ещё вернёмся). Но эти выражения имеют разный тип — <span style=" font-family:'Courier New,courier';">int (*TYPE)[5]</span> и <span style=" font-family:'Courier New,courier';">int *TYPE</span>, поэтому сравнить их при помощи == не получится. Но можно применить трюк с <span style=" font-family:'Courier New,courier';">void *</span>: следующее выражение будет истинным: <span style=" font-family:'Courier New,courier';">(void *)&amp;x == (void *)&amp;(x[0])</span>.<br /><br />Хорошо, будем считать, я вас убедил, что массив — это именно массив, а не что-нибудь ещё. Откуда тогда берётся вся эта путаница между указателями и массивами? Дело в том, что имя массива почти при любых операциях преобразуется в указатель на его нулевой элемент.<br /><br />Итак, мы объявили <span style=" font-family:'Courier New,courier';">int x[5]</span>. Если мы теперь пишем <span style=" font-family:'Courier New,courier';">x + 0</span>, то это преобразует наш x (который имел тип <span style=" font-family:'Courier New,courier';">int TYPE[5]</span>, или, более точно, <span style=" font-family:'Courier New,courier';">int (&amp;TYPE)[5]</span>) в <span style=" font-family:'Courier New,courier';">&amp;(x[0])</span>, т. е. в указатель на нулевой элемент массива x. Теперь наш x имеет тип <span style=" font-family:'Courier New,courier';">int *TYPE</span>.<br /><br />Конвертирование имени массива в <span style=" font-family:'Courier New,courier';">void *</span> или применение к нему == тоже приводит к предварительному преобразованию этого имени в указатель на первый элемент, поэтому:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">&amp;x == x // ошибка компиляции, разные типы: int (*TYPE)[5] и int *TYPE</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">(void *)&amp;x == (void *)x // истина</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x == x + 0 // истина</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x == &amp;(x[0]) // истина</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Операция []</span>. Запись <span style=" font-family:'Courier New,courier';">a[b]</span> всегда эквивалентна <span style=" font-family:'Courier New,courier';">*(a + b)</span> (напомню, что мы не рассматриваем переопределения <span style=" font-family:'Courier New,courier';">operator[]</span> и других операций). Таким образом, запись <span style=" font-family:'Courier New,courier';">x[2]</span> означает следующее:<br /></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">x[2] эквивалентно *(x + 2)</span></li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">x + 2 относится к тем операциям, при которых имя массива преобразуется в указатель на его первый элемент, поэтому это происходит</li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Далее, в соответствии с моими объяснениями выше, x + 2 эквивалентно (int *)((char *)x + 2 * sizeof (int)), т. е. x + 2 означает «сдвинуть указатель x на два int'а»</li>
<li style=" color:#000000;" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Наконец, от результата берётся операция разыменования и мы извлекаем тот объект, который размещён по этому сдвинутому указателю</li></ul>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /><br />Типы у участвовавших выражений следующие:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x // int (&amp;TYPE)[5], после преобразования типа: int *TYPE</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x + 2 // int *TYPE</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">*(x + 2) // int &amp;TYPE</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x[2] // int &amp;TYPE</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Также замечу, что слева от квадратных скобок необязательно должен стоять именно массив, там может быть любой указатель. Например, можно написать <span style=" font-family:'Courier New,courier';">(x + 2)[3]</span>, и это будет эквивалентно <span style=" font-family:'Courier New,courier';">x[5]</span>. Ещё замечу, что <span style=" font-family:'Courier New,courier';">*a</span> и <span style=" font-family:'Courier New,courier';">a[0]</span> всегда эквивалентны, как в случае, когда a — массив, так и когда a — указатель.<br /><br />Теперь, как я и обещал, я возвращаюсь к <span style=" font-family:'Courier New,courier';">&amp;(x[0])</span>. Теперь ясно, что в этом выражении сперва x преобразуется в указатель, затем к этому указателю в соответствии с вышеприведённым алгоритмом применяется <span style=" font-family:'Courier New,courier';">[0]</span> и в результате получается значение типа <span style=" font-family:'Courier New,courier';">int &amp;TYPE</span>, и наконец, при помощи &amp; оно преобразуется к типу <span style=" font-family:'Courier New,courier';">int *TYPE</span>. Поэтому, объяснять при помощи этого сложного выражения (внутри которого уже выполняется преобразование массива к указателю) немного более простое понятие преобразования массива к указателю — это был немного мухлёж.<br /><br /><span style=" font-weight:600;">А теперь вопрос на засыпку</span>: что такое <span style=" font-family:'Courier New,courier';">&amp;x + 1</span>? Что ж, <span style=" font-family:'Courier New,courier';">&amp;x</span> — это указатель на весь массив целиком, <span style=" font-family:'Courier New,courier';">+ 1</span> приводит к шагу на весь этот массив. Т. е. <span style=" font-family:'Courier New,courier';">&amp;x + 1</span> — это <span style=" font-family:'Courier New,courier';">(int (*)[5])((char *)&amp;x + sizeof (int [5]))</span>, т. е. <span style=" font-family:'Courier New,courier';">(int (*)[5])((char *)&amp;x + 5 * sizeof (int))</span> (здесь <span style=" font-family:'Courier New,courier';">int (*)[5]</span> — это <span style=" font-family:'Courier New,courier';">int (*TYPE)[5]</span>). Итак, <span style=" font-family:'Courier New,courier';">&amp;x + 1</span> численно равно <span style=" font-family:'Courier New,courier';">x + 5</span>, а не <span style=" font-family:'Courier New,courier';">x + 1</span>, как можно было бы подумать. Да, в результате мы указываем на память, которая находится за пределами массива (сразу после последнего элемента), но кого это волнует? Ведь в C всё равно не проверяется выход за границы массива. Также, заметим, что выражение <span style=" font-family:'Courier New,courier';">*(&amp;x + 1) == x + 5</span> истинно. Ещё его можно записать вот так: <span style=" font-family:'Courier New,courier';">(&amp;x)[1] == x + 5</span>. Также будет истинным <span style=" font-family:'Courier New,courier';">*((&amp;x)[1]) == x[5]</span>, или, что тоже самое, <span style=" font-family:'Courier New,courier';">(&amp;x)[1][0] == x[5]</span> (если мы, конечно, не схватим segmentation fault за попытку обращения за пределы нашей памяти :)).<br /><br /><span style=" font-weight:600;">Массив нельзя передать как аргумент в функцию</span>. Если вы напишите <span style=" font-family:'Courier New,courier';">int x[2]</span> или <span style=" font-family:'Courier New,courier';">int x[]</span> в заголовке функции, то это будет эквивалентно <span style=" font-family:'Courier New,courier';">int *x</span> и в функцию всегда будет передаваться указатель (sizeof от переданной переменной будет таким, как у указателя). При этом размер массива, указанный в заголовке будет игнорироваться. Вы запросто можете указать в заголовке <span style=" font-family:'Courier New,courier';">int x[2]</span> и передать туда массив длины 3.<br /><br />Однако, в C++ существует способ передать в функцию ссылку на массив:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">void f (int (&amp;x)[5])</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  // sizeof (x) здесь равен 5 * sizeof (int)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int main (void)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  int x[5];</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  f (x); // OK</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  f (x + 0); // Нельзя</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  int y[7];</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  f (y); // Нельзя, не тот размер</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">При такой передаче вы всё равно передаёте лишь ссылку, а не массив, т. е. массив не копируется. Но всё же вы получаете несколько отличий по сравнению с обычной передачей указателя. Передаётся ссылка на массив. Вместо неё нельзя передать указатель. Нужно передать именно массив указанного размера. Внутри функции ссылка на массив будет вести себя именно как ссылка на массив, например, у неё будет sizeof как у массива.<br /><br />И что самое интересное, эту передачу можно использовать так:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">// Вычисляет длину массива</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">template &lt;typename t, size_t n&gt; size_t len (t (&amp;a)[n])</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">{</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  return n;</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Похожим образом реализована функция std::end в C++11 для массивов.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">«Указатель на массив»</span>. Строго говоря, «указатель на массив» — это именно указатель на массив и ничто другое. Иными словами:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int (*a)[2]; // Это указатель на массив. Самый настоящий. Он имеет тип int (*TYPE)[2]</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int b[2];</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int *c = b; // Это не указатель на массив. Это просто указатель. Указатель на первый элемент некоего массива</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int *d = new int[4]; // И это не указатель на массив. Это указатель</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Однако, иногда под фразой «указатель на массив» неформально понимают указатель на область памяти, в которой размещён массив, даже если тип у этого указателя неподходящий. В соответствии с таким неформальным пониманием c и d (и <span style=" font-family:'Courier New,courier';">b + 0</span>) — это указатели на массивы.<br /><br /><span style=" font-weight:600;">Многомерные массивы</span>. Если объявлено <span style=" font-family:'Courier New,courier';">int x[5][7]</span>, то x — это не массив длины 5 неких указателей, указывающих куда-то далеко. Нет, x теперь — это единый монолитный блок размером 5 x 7, размещённый на стеке. <span style=" font-family:'Courier New,courier';">sizeof (x)</span> равен <span style=" font-family:'Courier New,courier';">5 * 7 * sizeof (int)</span>. Элементы располагаются в памяти так: <span style=" font-family:'Courier New,courier';">x[0][0]</span>, <span style=" font-family:'Courier New,courier';">x[0][1]</span>, <span style=" font-family:'Courier New,courier';">x[0][2]</span>, <span style=" font-family:'Courier New,courier';">x[0][3]</span>, <span style=" font-family:'Courier New,courier';">x[0][4]</span>, <span style=" font-family:'Courier New,courier';">x[0][5]</span>, <span style=" font-family:'Courier New,courier';">x[0][6]</span>, <span style=" font-family:'Courier New,courier';">x[1][0]</span> и так далее. Когда мы пишем <span style=" font-family:'Courier New,courier';">x[0][0]</span>, события развиваются так:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x // int (&amp;TYPE)[5][7], после преобразования: int (*TYPE)[7]</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x[0] // int (&amp;TYPE)[7], после преобразования: int *TYPE</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">x[0][0] // int &amp;TYPE</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">То же самое относится к <span style=" font-family:'Courier New,courier';">**x</span>. Замечу, что в выражениях, скажем, <span style=" font-family:'Courier New,courier';">x[0][0] + 3</span> и <span style=" font-family:'Courier New,courier';">**x + 3</span> в реальности извлечение из памяти происходит только один раз (несмотря на наличие двух звёздочек), в момент преобразования окончательной ссылки типа <span style=" font-family:'Courier New,courier';">int &amp;TYPE</span> просто в <span style=" font-family:'Courier New,courier';">int TYPE</span>. Т. е. если бы мы взглянули на ассемблерный код, который генерируется из выражения <span style=" font-family:'Courier New,courier';">**x + 3</span>, мы бы в нём увидели, что операция извлечения данных из памяти выполняется там только один раз. <span style=" font-family:'Courier New,courier';">**x + 3</span> можно ещё по-другому записать как <span style=" font-family:'Courier New,courier';">*(int *)x + 3</span>.<br /><br />А теперь посмотрим на такую ситуацию:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">int **y = new int *[5];</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">for (int i = 0; i != 5; ++i)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  {</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">    y[i] = new int[7];</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">  }</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Что теперь есть y? y — это указатель на массив (в неформальном смысле!) указателей на массивы (опять-таки, в неформальном смысле). Нигде здесь не появляется единый блок размера 5 x 7, есть 5 блоков размера <span style=" font-family:'Courier New,courier';">7 * sizeof (int)</span>, которые могут находиться далеко друг от друга. Что есть <span style=" font-family:'Courier New,courier';">y[0][0]</span>?</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">y // int **&amp;TYPE</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">y[0] // int *&amp;TYPE</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier 10 Pitch'; color:#6a0e07;">y[0][0] // int &amp;TYPE</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier 10 Pitch'; color:#6a0e07;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Теперь, когда мы пишем <span style=" font-family:'Courier New,courier';">y[0][0] + 3</span>, извлечение из памяти происходит два раза: извлечение из массива y и последующее извлечение из массива <span style=" font-family:'Courier New,courier';">y[0]</span>, который может находиться далеко от массива y. Причина этого в том, что здесь не происходит преобразования имени массива в указатель на его первый элемент, в отличие от примера с многомерным массивом x. Поэтому <span style=" font-family:'Courier New,courier';">**y + 3</span> здесь не эквивалентен <span style=" font-family:'Courier New,courier';">*(int *)y + 3</span>.<br /><br />Объясню ещё разок. <span style=" font-family:'Courier New,courier';">x[2][3]</span> эквивалентно <span style=" font-family:'Courier New,courier';">*(*(x + 2) + 3)</span>. И <span style=" font-family:'Courier New,courier';">y[2][3]</span> эквивалентно <span style=" font-family:'Courier New,courier';">*(*(y + 2) + 3)</span>. Но в первом случае наша задача найти «третий элемент во втором ряду» в едином блоке размера 5 x 7 (разумеется, элементы нумеруются с нуля, поэтому этот третий элемент будет в некотором смысле четвёртым :)). Компилятор вычисляет, что на самом деле нужный элемент находится на <span style=" font-family:'Courier New,courier';">2 * 7 + 3</span>-м месте в этом блоке и извлекает его. Т. е. <span style=" font-family:'Courier New,courier';">x[2][3]</span> здесь эквивалентно <span style=" font-family:'Courier New,courier';">((int *)x)[2 * 7 + 3]</span>, или, что то же самое, <span style=" font-family:'Courier New,courier';">*((int *)x + 2 * 7 + 3)</span>. Во втором случае сперва извлекает 2-й элемент в массиве y, а затем 3-й элемент в полученном массиве.<br /><br />В первом случае, когда мы делаем <span style=" font-family:'Courier New,courier';">x + 2</span>, мы сдвигаемся сразу на <span style=" font-family:'Courier New,courier';">2 * sizeof (int [7])</span>, т. е. на <span style=" font-family:'Courier New,courier';">2 * 7 * sizeof (int)</span>. Во втором случае, <span style=" font-family:'Courier New,courier';">y + 2</span> — это сдвиг на <span style=" font-family:'Courier New,courier';">2 * sizeof (int *)</span>.<br /><br />В первом случае <span style=" font-family:'Courier New,courier';">(void *)x</span> и <span style=" font-family:'Courier New,courier';">(void *)*x</span> (и <span style=" font-family:'Courier New,courier';">(void *)&amp;x</span>!) — это один и тот же указатель, во втором — это не так. </p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>
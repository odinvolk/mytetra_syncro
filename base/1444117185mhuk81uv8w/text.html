<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Миф №11: Delphi приложение занимает много памяти</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Я уже <a href="http://www.gunsmoker.ru/2010/12/blog-post.html"><span style=" text-decoration: underline; color:#0000ff;">высказывался на эту тему</span></a> и даже говорил о <a href="http://www.gunsmoker.ru/2009/05/blog-post_24.html"><span style=" text-decoration: underline; color:#0000ff;">типичных ошибках при поиске утечек памяти</span></a>.<br /><br />Самое время взяться за эту легенду!<br /><br />Я взял последнюю версию Delphi на сегодня - Delphi XE (ведь известно, чем старше версия Delphi, тем больший размер она имеет) и создал в ней два пустых приложения - VCL Forms и консольное. Запускаем и видим - VCL Forms:<br /><br /></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image11306.png" width="1062" height="54" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />И консольное:<br /><br /></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image10719.png" width="1060" height="53" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Вы только посмотрите на эти числа: около 80 и 57 мегабайт! И это - пустые приложения. Просто ужасно.<br /><br />Кажется, что легенда подтверждена, но так ли это? Давайте посмотрим внимательнее.<br /><br />Напомню, что это - <span style=" font-weight:600;">виртуальная</span> память. Никого не волнует, сколько её вы захапаете. Для экосистемы приложений важно, сколько оперативной (физической) памяти вы занимаете. Почему? Ну, чем плохо, что вы тратите много ресурсов? В абстрактном вакууме - ничем. Если в системе есть ресурсы - тратьте их как угодно. Но на практике машину не покупают для запуска исключительно вашей программы, поэтому здесь важно, что на машине работают и <span style=" font-weight:600;">другие программы</span>. Вот почему важно, чтобы вы оставляли как можно больше совместных ресурсов свободными - чтобы ими могло воспользоваться больше программ. Но ведь виртуальное адресное пространство не является общим ресурсом! Оно своё у каждой программы. А общий ресурс - это процессор и физическая память. Вот они делятся между всеми программами, в отличие от виртуального адресного пространства, которое выделяется каждой программе в эксклюзивное пользование.<br /><br />Мне кажется, что этот миф происходит из неосознавания этой связи.<br /><br />Но легенда ещё не разрушена - что там у нас с физической памятью?<br /><br />Каждой программе при её работе выделяется физическая память. Программа не может работать с памятью, выгруженной на диск. Если программа выполняет код, находящийся в файле подкачки, либо обращается к данным, выгруженным на диск, то система автоматически загрузит эти код и данные в оперативную память. Если там есть свободное место. Если его там нет - то часть старых данных (к которым давно не было обращения или к ним обращаются редко) будет выгружена на диск, чтобы освободить место для новых данных. Оперативная память тратится и на такие вещи как дисковый кэш.<br /><br />Итак, что там с оперативной памятью в нашей программе? Если вы посмотрите на снимки экрана выше, то получите два числа: <span style=" font-family:'Courier New,courier';">10'072</span> Кб для VCL Forms и <span style=" font-family:'Courier New,courier';">3'548</span> Кб для консольного (колонка &quot;Working Set Size&quot;, это значение также называется &quot;песочницей&quot; программы и показывается Диспетчером Задач в колонке &quot;Память&quot;). Кажется, что это огромные значения - в несколько раз больше размера .exe файлов (который равен <span style=" font-family:'Courier New,courier';">894</span> Кб для VCL Forms и <span style=" font-family:'Courier New,courier';">22</span> Кб для консольного).<br /><br />Кажется, что теперь легенда подтверждена? Но не будем спешить с выводами.<br /><br />Как мы узнали выше, память в адресном пространстве, хотя и выделяется с кратностью в <span style=" font-family:'Courier New,courier';">64</span> Кб, но минимальным блоком (для прочих операций с памятью) является <span style=" font-weight:600;">страница памяти</span> (она имеет размер в <span style=" font-family:'Courier New,courier';">4</span> Кб на текущих редакциях Windows). Кроме того, мы узнали, что одна и та же страница памяти может присутствовать (быть ассоциирована) с несколькими программами (адресными пространствами). Вспомните проецируемые в память файлы.<br /><br />К чему я это говорю? <br /><br />Когда вы запускаете одну и ту же программу второй раз, система просто открывает другое проецируемое в память представление объекта &quot;проекция файла&quot;, идентифицирующего образ исполняемого файла. С помощью проецируемых в память файлов несколько одновременно выполняемых экземпляров программы могут совместно использовать один и тот же код, загруженный в оперативную память. Т.е. система просто-напросто проецирует страницы виртуальной памяти, содержащие код и данные .exe файла, второй программы на адресное пространство первого экземпляра программы.<br /><br />Если один экземпляр программы модифицирует какие-либо данные, размещенные на общей (разделяемой)странице данных, система перехватывает эту попытку, выделяет новый блок памяти, копирует в него нужную программе страницу и после этого разрешает запись в новый блок памяти. Благодаря этому механизму (называемому copy-on-write - копирование при записи), работа остальных экземпляров программы не нарушается. Аналогичная цепочка событий происходит и при отладке приложения. Например, запустив несколько экземпляров программы, вы хотите отладить только один из них. Вызвав отладчик, вы ставите в строке исходного кода точку прерывания. Отладчик модифицирует ваш код, заменяя одну из команд на языке ассемблера другой — заставляющей активизировать сам отладчик. И снова система использует копирование при записи. Обнаружив попытку отладчика изменить код, она выделяет новый блок памяти, копирует туда нужную страницу и позволяет отладчику модифицировать код на этой копии.<br /><br />Иными словами, то, что вашей программе выделено <span style=" font-family:'Courier New,courier';">10'072</span> Кб оперативной памяти, - ещё не означает, что это &quot;её вина&quot;. Т.е. эти <span style=" font-family:'Courier New,courier';">10'072</span> Кб - не лично ваша собственность, они совместно используются ещё и другими программами. Можно ли узнать, сколько в этих 10 Мб ваших данных? Да, можно. Это значения в колонке &quot;WS Private&quot; (private working set). Для VCL Forms мы получаем <span style=" font-family:'Courier New,courier';">1'604</span> Кб, а для консольного - <span style=" font-family:'Courier New,courier';">876</span> Кб. Это и есть те реальные значения, на которые ваша программа загружает систему. Ради сравнения - эти же программы на Delphi 3 дают <span style=" font-family:'Courier New,courier';">692</span> Кб и <span style=" font-family:'Courier New,courier';">332</span> Кб соответственно. Достаточно мало и намного меньше тех значений, о которых обычно думает тот, кто кричит: &quot;ай как много занимает памяти Delphi приложение&quot;. И это в системе, где куча свободной ОЗУ и нет давления на память - т.е. это почти максимум. В условиях давления на память эти значения были бы ещё ниже. Посмотрите, как в мифе №1 размер потребляемой Total Commander-ом оперативной памяти снизился с <span style=" font-family:'Courier New,courier';">1'080</span> Кб до <span style=" font-family:'Courier New,courier';">136</span> Кб в условиях нехватки памяти (выделения <span style=" font-family:'Courier New,courier';">2x512</span> Мб на системе с <span style=" font-family:'Courier New,courier';">256</span> Мб ОЗУ). И заметьте, что даже при выделении <span style=" font-family:'Courier New,courier';">1</span> Гб памяти, песочница вашей программы осталась очень компактной - менее <span style=" font-family:'Courier New,courier';">2</span> Мб: потому что к этой памяти мы не обращались. Мы её только выделили.<br /><br />Статус мифа: <span style=" font-weight:600; color:#ff0000;">busted</span>.<br /></p></body></html>
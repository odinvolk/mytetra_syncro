<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:x-large; font-weight:600;">Как правильно читать объявления в Си </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Даже совсем зеленые программисты на Си, не испытывают проблем с чтением таких объявлений:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">int foo[5]; // foo массив из 5 элементов типа int</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">char *foo; // foo указатель на char</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">double foo(); // foo функция возвращающая значение типа double</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New'; color:#6a0e07;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Но как только объявления становятся немного сложнее, проблематично точно сказать что это. Например:<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">char *(*(**foo[][8])())[];</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New'; color:#6a0e07;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Оказывается, что правила чтения произвольно совокупных объявлений легко учатся даже начинающими программистами (хоть и невозможно использовать такую объявленную переменную)</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Основные и производные типы</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />В дополнении к имени переменной, объявление состоит из одного основного типа и может содержать еще и производный тип, и это ключ к пониманию различий между ними.<br /><br />Основные типы:<br /></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• char </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• signed char </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• unsigned char </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• short </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• unsigned short </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• int </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• unsigned int </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• long </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• unsigned long </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• float </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• double</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• long double </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• void </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• struct tag </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• union tag </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• enum tag </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• long long </li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">• unsigned long long </li></ul>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Объявление может содержать только <span style=" font-weight:600;">один основной тип</span>, и он всегда находится слева выражения. Основные типы дополняются производными типами, в Си их три:<br /><br />1)<span style=" font-weight:600;"> * — указатель на ...</span><br />Обозначается символом *, и важно понимать что указатель <span style=" font-weight:600;">всегда</span> на что-нибудь указывает.<br /><br />2) <span style=" font-weight:600;">[] — массив из… </span><br />Массив может быть безразмерный — [], а может быть и размерный [10]. Правда размерный массив или нет, это неважно при чтении объявлений (обычно все же пишется размер массива). Должно быть понятно что массив всегда «массив из чего-нибудь».<br /><br />3)<span style=" font-weight:600;"> () — функция возвращающая ...</span><br />Обычно обозначается парой круглых скобок (), но также возможно что внутри их будут модели параметров.Список параметров (если он есть) не играет существенной роли при чтении объявлений, и мы его обычно игнорируем. Заметим, что круглые скобки используемые для обозначения функций, отличаются от скобок служащих для группировки: группирующие скобки окружают переменные, тогда как скобки для обозначения функция находятся справа.Функция не имеет смысла если она ничего не возврщает(когда мы объявляем функцию с возвращаемым типом значения void, то это просто выглядит как будто функция возвращает значения типа void)<br /><br />Производные типы <span style=" font-weight:600;">всегда</span> что то модифицируют, будь то основной тип или производный, и что бы правильно читать объявления, всегда нужно вставлять предлог («на», «из», «возвращающая»). Используя при чтении «указатель» вместо «указатель на», вы точно прочитаете объявление неправильно.<br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Приоритет операторов.</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Почти каждый программист Си знаком с таблицами приоритетов операторов, в которых говорится что (например) умножение и деление имеют более высокий приоритет (выполняются раньше) чем сложение и вычитание, и группирующие скобки используются для изменения этого приоритета.Это кажется нормальным для «обычных» выражений, но те же правила применимы и к объявлениям — они просто «типовые», а не вычислительные. <br />Операторы «массив из»<span style=" font-weight:600;">[]</span> и «функция возвращающая»<span style=" font-weight:600;">()</span> имеют более высокий приоритет чем «указатель на», что приводит к довольно простому правилу декодирования:<br /><span style=" font-weight:600;">Всегда начинайте с имени переменной:</span><br /><br /><span style=" font-weight:600;">foo это .....</span><br /><br /><span style=" font-weight:600;">И заканчивайте декодирование основным типом:</span><br /><br /><span style=" font-weight:600;">… типа int</span><br /><br />То что будет в середине обычно сложнее разобрать, но можно сформулировать правило:<br /><span style=" font-weight:600;">двигайтесь вправо, если это возможно, и перемещайтесь влево если это необходимо </span><br />Начиная с имени переменной, соблюдая правила приоритета, двигайтесь вправо насколько это возможно вычеркивая лексемы, пока не дойдете до группирующих скобок.После же перемещайтесь налево в соответствии со скобками.<br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Простой пример.</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Давайте начнем с простого примера:<br />-&gt; <span style=" font-weight:600;">long **foo[7];</span><br /><br />Давайте попробуем разобраться, сосредоточившись на одной или двух частях, выделяя их <span style=" font-weight:600;">жирным шрифтом</span>, а то с чем мы уже определились будем <span style=" text-decoration: line-through;">зачеркивать</span><br /><br />-&gt; <span style=" color:#ff0000;">long</span> **<span style=" color:#ff0000;">foo</span> [7];<br /><br />Начинаем с имени переменной и заканчиваем основным типом:<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#ff0000;">foo это… типа long</span><br /><br />Разбираем дальше:<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">-&gt; <span style=" text-decoration: line-through;">long</span> **<span style=" text-decoration: line-through;">foo</span><span style=" color:#ff0000;">[7]</span>;<br /><br />В данной момент имя переменной окружает лексема значащая «массив из 7 » и лексема значащая «указатель на», и в соответствии с правилом двигаемся вправо и дописываем к нашему описанию «массив из 7 »:<br />foo это <span style=" color:#ff0000;">массив из 7 </span>… типа long<br /><br />-&gt; <span style=" text-decoration: line-through;">long</span> *<span style=" color:#ff0000;">*</span><span style=" text-decoration: line-through;">foo[7]</span>;<br /><br />Вправо больше некуда двигаться, а ближайшая лексема это «указатель на». Добавим её: <br />foo это массив из 7 <span style=" color:#ff0000;">указателей на</span>… значение типа long<br /><br />-&gt; <span style=" text-decoration: line-through;">long</span> <span style=" color:#ff0000;">*</span><span style=" text-decoration: line-through;">*foo[7]</span>;<br /><br />Ближайшая лексема так же «указатель на», добавим и её:<br />foo это массив из 7 указателей на <span style=" color:#ff0000;">указатели на</span> значение типа long<br /><br />Ну вот и все. <br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Сложный пример</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Чтобы проверить наши навыки, нам нужно попробовать прочитать очень сложное объявление, которое никогда не встретится в реальной жизни (на самом деле мы очень долго думали как можно применить это объявление).Но нужно показать что правила работают и для очень сложных деклараций.<br /><br />-&gt; <span style=" color:#ff0000;">char</span> *(*(**<span style=" color:#ff0000;">foo</span> [][8])())[];<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Все объявления стоит начинать читать с «имя переменной… основной тип» <br /><span style=" color:#ff0000;">foo это… типа char</span>;<br /><br />-&gt;<span style=" text-decoration: line-through;">char</span> *(*(**<span style=" text-decoration: line-through;">foo</span> <span style=" color:#ff0000;">[]</span>[8])())[];<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">К имени примыкают «указатель на» и «массив из», идем вправо:<br />foo это <span style=" color:#ff0000;">массив из</span>… типа char;<br /><br /><span style=" text-decoration: line-through;">char</span> *(*(**<span style=" text-decoration: line-through;">foo[]</span><span style=" color:#ff0000;">[8]</span>)())[];<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Мы можем выбрать правую или левую примыкающую лексему, но правило гласит что, необходимо двигаться вправо насколько это возможно, пока к внутренней части группирующих скобок что нибудь примыкает, поэтому идем вправо.<br />foo это массив из <span style=" color:#ff0000;">массив из</span>… типа char;<br /><br />-&gt;<span style=" text-decoration: line-through;">char</span> *(*(*<span style=" color:#ff0000;">*</span> <span style=" text-decoration: line-through;">foo[][8]</span>)())[];<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Мы дошли до группирующих скобок, и дальше двигаться направо не представляется возможным, поэтому двигаемся влево пока не дойдем до парной группирующей скобки, чтоб вычеркнуть все остальные лексемы.<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">foo это массив из массив из <span style=" color:#ff0000;">указателей на</span>… типа char;<br /><br />-&gt;<span style=" text-decoration: line-through;">char</span> *(*(<span style=" color:#ff0000;">*</span> <span style=" text-decoration: line-through;">*foo[][8]</span>)())[];<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Снова двигаемся влево и приписываем «указатель на». <br />foo это массив из массив из указателей на <span style=" color:#ff0000;">указатели на</span>… типа char;<br /><br />-&gt;<span style=" text-decoration: line-through;">char</span> *(* <span style=" text-decoration: line-through;">(** foo[][8])</span><span style=" color:#ff0000;">()</span>)[];<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">После того как мы дописали «указатель на» в предыдущем шаге, мы дошли до парной группирующей скобки, так что продолжим присоединять и к «группирующим скобкам». Сейчас к ним примыкает«функция возвращает» справа и «указатель на» слева. Двигаемся вправо.<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">foo это массив из массив из указателей на указатели на <span style=" color:#ff0000;">функцию возвращающую</span>… типа char;<br /><br />-&gt;<span style=" text-decoration: line-through;">char</span> *(<span style=" color:#ff0000;">*</span> <span style=" text-decoration: line-through;">(** foo[][8])()</span>)[];<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Мы снова уперлись в группирующие скобки, поэтому снова возвращаемся налево.<br />foo это массив из массив из указателей на указатели на функцию возвращающую <span style=" color:#ff0000;">указатели на</span>… типа char;<br /><br />-&gt;<span style=" text-decoration: line-through;">char</span> *<span style=" text-decoration: line-through;">(*(** foo[][8])())</span><span style=" color:#ff0000;">[]</span>;<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обойдя группирующие скобки, видим что сейчас к вычеркнутым лексемам примыкает «массив из» справа и «указатель на» слева, «массив из» находится справа, добавим.<br />foo это массив из массив из указателей на указатели на функцию возвращающую указатели на <span style=" color:#ff0000;">массив из</span>… типа char;<br /><br />-&gt;<span style=" text-decoration: line-through;">char</span> <span style=" color:#ff0000;">*</span><span style=" text-decoration: line-through;">(*(** foo[][8])())[]</span>;<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Ну и добавляем последнюю лексему:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">foo это массив из массив из указателей на указатели на функцию возвращающую указатели на массив из <span style=" color:#ff0000;">указателей на</span> тип char;</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Мы правда не знаем как это применить, но описание типа корректно.<br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Абстрактные объявления</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /><br />Стандарт Си позволяет использовать абстрактные объявления, когда тип должен быть объявлен, но не связан с именем переменной. Это используется при приведении типов, и как аргумент <span style=" font-weight:600;">sizeof</span> — иногда это выглядит ужасающе: <br /><br /><span style=" font-weight:600;">int (*(*)())()</span>;<br /><br />Естественно возникает вопрос с чего же начать, так вот ответ будет звучать так «надо найти место, где будет стоять имя переменной и рассматривать как обычное объявление». Такое место будет только одно, и найти его на самом деле очень просто. Используя правила синтаксиса, которые мы знаем:<br /><br />•справа от всех лексем «указатель на» <br />•слева от всех лексем «массив из» <br />•слева от всех лексем «функция возвращает»<br />•внутри всех группирующих скобок<br /><br />А теперь посмотрим на пример. Мы видим что левый набор лексем «указатель на» устанавливает одну границу и правый набор лексем «функция возвращает» устанавливает другую границу.<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" text-decoration: line-through;">int (*(*</span> <span style=" color:#ff0000;">•)•</span> <span style=" text-decoration: line-through;">())()</span>;<br /><br />Красные точки <span style=" color:#ff0000;">•</span> показывают куда можно поместить имя переменной, но только одно место удовлетворяет условиям (внутри группирующих скобок). И что же у нас тогда с объявлением? А вот что:<br /><br /><span style=" font-weight:600;">int (*(*foo)())()</span>;<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">которое наши правила описывают как:<br />foo это указатель на функцию возвращающую указатель на функцию возвращающую значение типа int<br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Семантические ограничения / Примечания</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Не все комбинации производных типов допускаются. Возможно создать объявления, прекрасно вписывающееся в синтаксические правила, но которые тем не менее будут ошибочны (будут правильны синтаксически, но ошибочны семантически, например)<br /><br /><span style=" font-weight:600;">• Невозможно создать массив функций</span><br />Но зато можно использовать массив указателей на функцию<br /><br /><span style=" font-weight:600;">•Функция не может возвращать функцию</span><br />Но может возвращать указатель на функцию<br /><br /><span style=" font-weight:600;">•Функция не может вернуть массив</span><br />Опять таки функция может вернуть указатель на массив<br /><br /><span style=" font-weight:600;">•В массивах только левая лексема [] может быть пустой</span><br />Си поддерживает многомерные массивы (например foo[1][2][3][4]), представляющие собой очень простую структуру данных. Однако, когда массив имеет больше чем одно измерение, то только первые скобки могут быть пустыми. <span style=" font-weight:600;">char foo[]</span> и <span style=" font-weight:600;">char foo[][5]</span> имеют право на существование, а вот char <span style=" font-weight:600;">foo[5][]</span> уже запрещено<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">•Тип «void» ограниченный</span><br />Тип «void» -это псевдо-тип, и переменные такого типа могут быть только «указатель на» и «функция возвращающая». Запрещено (точнее невозможно) использовать «массив из void» и просто переменные типа «void».<br />void *foo; //разрешено<br />void foo(); //разрешено<br />void foo; //запрещено<br />void foo[]; //запрещено<br /><br /></p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Добавление типа соглашения вызова</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />При разработке на платформе windows, часто добавляется, к описанию функции соглашение вызова.Это указывает компьютеру какой метод использовать для вызова функции в запросе, и метод должен быть таким же, какой и ожидает функция. Вот как это выглядит:<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">extern int __cdecl main(int argc, char **argv);</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">extern BOOL __stdcall DrvQueryDriverInfo(DWORD dwMode, PVOID pBuffer,</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">DWORD cbBuf, PDWORD pcbNeeded);</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Такое добавление очень часто встречается в разработке под win32, оно достаточно простое для понимания. Больше информации в статье <a href="http://www.unixwiz.net/techtips/win32-callconv.html"><span style=" text-decoration: underline; color:#0057ae;">Использование соглашения вызова win32 </span></a>.<br /><br />Где это становится каким-то более сложным, так это когда соглашение вызова должно быть включено в «указатель» (включая typedef), потому, что лексема не выглядит так, чтобы соответствовать нормальной схеме.Это часто используется когда речь идет о работе с <span style=" font-weight:600;">LoadLibrary()</span> и <span style=" font-weight:600;">GetProcAddress()</span> API для обращения к вызову функции из недавно загруженной библиотеки.<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Это можно часто встретить с typedef: <br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">typedef BOOL (__stdcall *PFNDRVQUERYDRIVERINFO)(</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">DWORD dwMode,</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">PVOID pBuffer,</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">DWORD cbBuf,</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">PDWORD pcbNeeded);</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">...</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New'; color:#6a0e07;"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">/* get the function address from the DLL */</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">pfnDrvQueryDriverInfo = (PFNDRVRQUERYDRIVERINFO)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a0e07;">GetProcAddress(hDll, &quot;DrvQueryDriverInfo&quot;)</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';"></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Согласование вызова это атрибут функции, а не указателя, поэтому при чтении это нужно ставить перед указателем, но все равно внутри группирующих скобок:<br /><br /><span style=" font-weight:600;">BOOL (__stdcall *foo)(...);</span><br /><br />Читается:<br />foo это указатель на __stdcall функцию возвращающую BOOL. <br /><br />p.s. О неточностях пишите, пожалуйста, в личку. </p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p></body></html>
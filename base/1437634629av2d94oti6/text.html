<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Как в PowerShell фильтровать вывод командлета</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#000000;">Where-Object – фильтр. Сводим результаты PowerShell к самому необходимому </span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В предыдущих статьях рубрики я рассказывал о том, как с помощью конвейера (|), объединяющего несколько команд PowerShell в цепочку, можно создавать простые отчеты, например: </p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New,courier';">get-aduser –f * -pr lastlogondate | select samaccountname,lastlogondate | sort lastlogondate</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Эта комбинация команд позволяет вывести список имен пользователей, выбрать только имена и даты последней регистрации и отсортировать результаты по дате последней регистрации. Результат выполнения такого запроса может содержать много ненужной информации. Предположим, нам требуется вывести имена и даты последней регистрации не всех пользователей, а только тех, кто не заходил в систему в течение определенного времени.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Эту задачу позволяет решить команда <span style=" font-family:'Courier New'; color:#6a1009;">where-object</span>, которую практически никогда не вызывают по полному имени. В большинстве случаев для ее вызова используется <span style=" font-family:'Courier New'; color:#6a1009;">where</span> или знак вопроса (<span style=" font-family:'Courier New'; color:#6a1009;">?</span>). В предыдущих публикациях речь шла о парах команд PowerShell, состоящих из команды вывода учетных записей, соответствующих определенному критерию и команды-действия (применение определенного действия к извлеченному подмножеству AD). Рассматривались и некоторые команды, содержащие фильтры: <span style=" font-family:'Courier New'; color:#6a1009;">get-aduser</span>, <span style=" font-family:'Courier New'; color:#6a1009;">search-adaccount</span> и другие.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Where-object – это фильтр. Чтобы понять синтаксис команды, начнем с примера. Для вывода пользователей, не запускавших систему после 1 января 2013 года, построим следующий запрос:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">get-aduser -f * | where {$_.lastlogondate -le «1 January 2013»}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Команда <span style=" font-family:'Courier New'; color:#6a1009;">get-aduser</span> извлекает все учетные записи пользователей домена. Результаты передаются по конвейеру команде <span style=" font-family:'Courier New'; color:#6a1009;">where-object</span>, которая проверяет каждый входящий объект на соответствие определенному критерию. Критерий, заключенный в фигурные скобки, заслуживает отдельного рассмотрения.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Запись <span style=" font-family:'Courier New'; color:#6a1009;">–le</span> означает «меньше или равно»; указанная справа дата также не вызывает вопросов. Остается разобраться, что такое <span style=" font-family:'Courier New'; color:#6a1009;">$_.lastlogondate</span>.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как уже было сказано, <span style=" font-family:'Courier New'; color:#6a1009;">where-object</span> анализирует приходящие по конвейеру данные. Понятно, что утверждение <span style=" font-family:'Courier New'; color:#6a1009;">(нечто) -le «1 January 2013»</span> предполагает сопоставление этого (нечто) с указанной датой. Таким образом, данное (нечто) должно быть именно тем, что в данный момент приходит по конвейеру.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Для обозначения того, что передано по конвейеру, используется символ <span style=" font-family:'Courier New'; color:#6a1009;">$_</span>. Мы уже знаем, что PowerShell имеет переменные, позволяющие хранить временную информацию в памяти компьютера. Переменную можно узнать по первому символу – знаку доллара (<span style=" font-family:'Courier New'; color:#6a1009;">$</span>). Переменные можно создавать в ходе работы, но у PowerShell, как и у большинства сред построения сценариев, есть и встроенные переменные, например <span style=" font-family:'Courier New'; color:#6a1009;">$true</span> и <span style=" font-family:'Courier New'; color:#6a1009;">$false</span>, хранящие значения <span style=" font-family:'Courier New'; color:#6a1009;">true</span> и <span style=" font-family:'Courier New'; color:#6a1009;">false</span>. По аналогии логично было бы хранить текущее содержимое конвейера в переменной <span style=" font-family:'Courier New'; color:#6a1009;">$pipeline</span>, но вместо этого используется переменная <span style=" font-family:'Courier New'; color:#6a1009;">$_</span>, которая в данном случае хранит весь передаваемый по конвейеру объект – учетную запись пользователя.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Однако приведенный в нашем примере критерий предусматривает сопоставление с датой (1 января 2013 г.) не всего объекта пользователя, а лишь его свойства <span style=" font-family:'Courier New'; color:#6a1009;">lastlogondate</span>. Задачу извлечения лишь нужной информации решает добавление точки и имени свойства, в результате чего получается запись <span style=" font-family:'Courier New'; color:#6a1009;">$_.lastlogondate</span>. Итак, усовершенствованный с помощью <span style=" font-family:'Courier New'; color:#6a1009;">where-object</span> запрос будет выглядеть следующим образом:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">get-aduser –f * -pr lastlogondate |? {$_.lastlogondate -le «1 January 2012»} | select samaccountname,lastlogondate | sort lastlogondate</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">С помощью <span style=" font-family:'Courier New'; color:#6a1009;">where-object</span> и <span style=" font-family:'Courier New'; color:#6a1009;">$_</span> можно строить любые виды фильтров. Например, вывести имена всех пользователей, чье имя (<span style=" font-family:'Courier New'; color:#6a1009;">SamAccountName</span>) начинается с <span style=" font-family:'Courier New'; color:#6a1009;">F</span>, позволяет такой запрос:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">get-aduser -f * | where {$_.samaccountname -like «f*&quot;}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Может возникнуть вопрос: зачем было тратить столько времени на обсуждение параметра -filter команды get-aduser? Почему бы не применять для всех запросов единую форму:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; color:#6a1009;">get-aduser -f * | where {$_. -like»&quot;}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">С технической точки зрения, для этого нет противопоказаний, кроме одного: такой подход может привести к излишней трате полосы пропускания и времени сервера. Команда get-aduser с фильтром посылает команду контроллеру домена (DC), и DC возвращает лишь небольшое подмножество AD. Когда же результат get-aduser -f * подается на вход where-object, у DC запрашиваются все учетные записи пользователей, после чего локальный процессор отфильтровывает их, оставляя только нужные данные. Таким образом, where-object – отличный универсальный инструмент, однако следует избегать его применения, когда у исходной команды get-whatever уже есть встроенный фильтр.</p>
<p style="-qt-paragraph-type:empty; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>